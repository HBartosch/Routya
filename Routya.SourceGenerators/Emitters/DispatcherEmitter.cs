using Routya.SourceGenerators.Models;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Routya.SourceGenerators.Emitters;

/// <summary>
/// Emits optimized, type-specific dispatcher code for maximum performance.
/// Generates direct dispatch methods that bypass runtime generic resolution.
/// </summary>
internal static class DispatcherEmitter
{
    public static string EmitGeneratedDispatcher(
        List<HandlerDescriptor> requestHandlers,
        Dictionary<string, List<HandlerDescriptor>> notificationHandlers)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Routya.Core.Abstractions;");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine();
        sb.AppendLine("namespace Routya.Generated");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// High-performance, compile-time optimized dispatcher.");
        sb.AppendLine("    /// Generated methods provide zero-overhead, type-specific dispatch.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public sealed class GeneratedRoutya : IGeneratedRoutya");
        sb.AppendLine("    {");
        sb.AppendLine("        private readonly IServiceProvider _serviceProvider;");
        sb.AppendLine();
        sb.AppendLine("        public GeneratedRoutya(IServiceProvider serviceProvider)");
        sb.AppendLine("        {");
        sb.AppendLine("            _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));");
        sb.AppendLine("        }");
        sb.AppendLine();

        // Generate type-specific SendAsync methods
        foreach (var handler in requestHandlers)
        {
            EmitRequestDispatchMethod(sb, handler);
        }

        // Generate type-specific PublishAsync methods
        foreach (var kvp in notificationHandlers)
        {
            EmitNotificationDispatchMethod(sb, kvp.Key, kvp.Value);
        }

        // Generate generic fallback methods
        EmitGenericFallbackMethods(sb);

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void EmitRequestDispatchMethod(StringBuilder sb, HandlerDescriptor handler)
    {
        var requestTypeName = GetFullTypeName(handler.RequestType);
        var responseTypeName = GetFullTypeName(handler.ResponseType!);
        
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Optimized dispatch for {requestTypeName}.");
        sb.AppendLine("        /// Zero dictionary lookups, direct handler resolution.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public async Task<{responseTypeName}> SendAsync(");
        sb.AppendLine($"            {requestTypeName} request,");
        sb.AppendLine($"            CancellationToken cancellationToken = default)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (request == null) throw new ArgumentNullException(nameof(request));");
        sb.AppendLine();
        
        // Check for pipeline behaviors
        sb.AppendLine($"            var behaviors = _serviceProvider.GetServices<IPipelineBehavior<{requestTypeName}, {responseTypeName}>>();");
        sb.AppendLine($"            var handler = _serviceProvider.GetRequiredService<{handler.ConcreteType}>();");
        sb.AppendLine();
        sb.AppendLine("            if (behaviors.Any())");
        sb.AppendLine("            {");
        sb.AppendLine("                // Build pipeline with behaviors");
        sb.AppendLine("                RequestHandlerDelegate<" + responseTypeName + "> handlerDelegate = (ct) => handler.HandleAsync(request, ct);");
        sb.AppendLine("                ");
        sb.AppendLine("                // Reverse to ensure correct execution order");
        sb.AppendLine("                foreach (var behavior in behaviors.Reverse())");
        sb.AppendLine("                {");
        sb.AppendLine("                    var currentDelegate = handlerDelegate;");
        sb.AppendLine("                    var currentBehavior = behavior;");
        sb.AppendLine("                    handlerDelegate = (ct) => currentBehavior.Handle(request, currentDelegate, ct);");
        sb.AppendLine("                }");
        sb.AppendLine();
        sb.AppendLine("                return await handlerDelegate(cancellationToken).ConfigureAwait(false);");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            // No behaviors - direct handler execution");
        sb.AppendLine("            return await handler.HandleAsync(request, cancellationToken).ConfigureAwait(false);");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void EmitNotificationDispatchMethod(
        StringBuilder sb,
        string notificationType,
        List<HandlerDescriptor> handlers)
    {
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Optimized parallel dispatch for {notificationType}.");
        sb.AppendLine($"        /// Executes {handlers.Count} handler(s) concurrently.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public async Task PublishAsync(");
        sb.AppendLine($"            {notificationType} notification,");
        sb.AppendLine($"            CancellationToken cancellationToken = default)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (notification == null) throw new ArgumentNullException(nameof(notification));");
        sb.AppendLine();

        // Resolve all handlers directly - caller manages scopes
        for (int i = 0; i < handlers.Count; i++)
        {
            var handler = handlers[i];
            sb.AppendLine($"            var handler{i} = _serviceProvider.GetRequiredService<{handler.ConcreteType}>();");
        }

        sb.AppendLine();

        // Execute handlers - optimized for zero allocations
        if (handlers.Count == 1)
        {
            sb.AppendLine($"            await handler0.Handle(notification, cancellationToken).ConfigureAwait(false);");
        }
        else if (handlers.Count == 2)
        {
            // Special case for 2 handlers: parallel execution without Task.WhenAll allocation
            sb.AppendLine("            var task0 = handler0.Handle(notification, cancellationToken);");
            sb.AppendLine("            var task1 = handler1.Handle(notification, cancellationToken);");
            sb.AppendLine("            await task0.ConfigureAwait(false);");
            sb.AppendLine("            await task1.ConfigureAwait(false);");
        }
        else
        {
            // For 3+ handlers, use Task.WhenAll (small allocation acceptable for many handlers)
            sb.AppendLine("            await Task.WhenAll(");
            for (int i = 0; i < handlers.Count; i++)
            {
                var comma = i < handlers.Count - 1 ? "," : "";
                sb.AppendLine($"                handler{i}.Handle(notification, cancellationToken){comma}");
            }
            sb.AppendLine("            ).ConfigureAwait(false);");
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void EmitGenericFallbackMethods(StringBuilder sb)
    {
    }

    private static string GetFullTypeName(Microsoft.CodeAnalysis.INamedTypeSymbol symbol)
    {
        var sb = new StringBuilder();
        
        // Get namespace prefix
        if (symbol.ContainingNamespace?.IsGlobalNamespace == false)
        {
            sb.Append(symbol.ContainingNamespace);
            sb.Append('.');
        }
        
        // Get type name
        sb.Append(symbol.Name);
        
        // Handle generic types
        if (symbol.IsGenericType && symbol.TypeArguments.Length > 0)
        {
            sb.Append('<');
            for (int i = 0; i < symbol.TypeArguments.Length; i++)
            {
                if (i > 0)
                    sb.Append(", ");
                    
                if (symbol.TypeArguments[i] is Microsoft.CodeAnalysis.INamedTypeSymbol namedTypeArg)
                {
                    sb.Append(GetFullTypeName(namedTypeArg));
                }
                else
                {
                    // Handle other type arguments (type parameters, arrays, etc.)
                    sb.Append(symbol.TypeArguments[i].ToDisplayString());
                }
            }
            sb.Append('>');
        }
        
        return sb.ToString();
    }
}
