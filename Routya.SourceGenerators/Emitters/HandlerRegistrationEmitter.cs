using Routya.SourceGenerators.Models;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Routya.SourceGenerators.Emitters
{
    /// <summary>
    /// Emits the AddGeneratedRoutya extension method with handler registrations.
    /// </summary>
    internal static class HandlerRegistrationEmitter
    {
        public static string Generate(
            List<HandlerDescriptor> requestHandlers,
            List<HandlerDescriptor> notificationHandlers)
        {
            var sb = new StringBuilder();

            // File header
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            sb.AppendLine("using Routya.Core.Abstractions;");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine();

            sb.AppendLine("namespace Routya.Generated");
            sb.AppendLine("{");
            
            // Generate the IGeneratedRoutya interface with only concrete methods
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Type-specific dispatcher interface generated at compile-time.");
            sb.AppendLine("    /// Use this interface for dependency injection to get concrete type-specific dispatch without generic fallbacks.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public interface IGeneratedRoutya");
            sb.AppendLine("    {");
            
            // Add concrete Send/SendAsync methods for each request handler
            foreach (var handler in requestHandlers)
            {
                var requestType = GetTypeName(handler.RequestType);
                var responseType = GetTypeName(handler.ResponseType!);
                
                if (handler.IsAsync)
                {
                    sb.AppendLine($"        /// <summary>Dispatches {requestType} to its handler.</summary>");
                    sb.AppendLine($"        System.Threading.Tasks.Task<{responseType}> SendAsync(");
                    sb.AppendLine($"            {requestType} request,");
                    sb.AppendLine($"            System.Threading.CancellationToken cancellationToken = default);");
                }
                else
                {
                    sb.AppendLine($"        /// <summary>Dispatches {requestType} to its handler.</summary>");
                    sb.AppendLine($"        {responseType} Send({requestType} request);");
                }
                sb.AppendLine();
            }
            
            // Add concrete PublishAsync methods for each notification type
            var notificationGroups = notificationHandlers.GroupBy(h => GetTypeName(h.RequestType));
            foreach (var group in notificationGroups)
            {
                var notificationType = group.Key;
                sb.AppendLine($"        /// <summary>Publishes {notificationType} to all registered handlers.</summary>");
                sb.AppendLine($"        System.Threading.Tasks.Task PublishAsync(");
                sb.AppendLine($"            {notificationType} notification,");
                sb.AppendLine($"            System.Threading.CancellationToken cancellationToken = default);");
                sb.AppendLine();
            }
            
            sb.AppendLine("    }");
            sb.AppendLine();
            
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Auto-generated handler registration extensions for Routya.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public static class RoutyaGeneratedExtensions");
            sb.AppendLine("    {");
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Registers all auto-discovered handlers using source generation.");
            sb.AppendLine("        /// This provides zero-overhead, compile-time optimized dispatching.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        public static IServiceCollection AddGeneratedRoutya(this IServiceCollection services)");
            sb.AppendLine("        {");
            
            // Request handler registrations
            if (requestHandlers.Any())
            {
                sb.AppendLine("            // Request/Response handler registrations");
                foreach (var handler in requestHandlers)
                {
                    var lifetime = GetLifetimeString(handler.Lifetime);
                    var handlerInterface = handler.IsAsync
                        ? $"IAsyncRequestHandler<{GetTypeName(handler.RequestType)}, {GetTypeName(handler.ResponseType!)}>"
                        : $"IRequestHandler<{GetTypeName(handler.RequestType)}, {GetTypeName(handler.ResponseType!)}>";
                    
                    // Register the concrete handler first
                    sb.AppendLine($"            services.Add{lifetime}<{GetTypeName(handler.HandlerType)}>();");
                    // Then register the interface â†’ implementation mapping
                    sb.AppendLine($"            services.Add{lifetime}<{handlerInterface}>(sp => sp.GetRequiredService<{GetTypeName(handler.HandlerType)}>());");
                }
                sb.AppendLine();
            }

            // Notification handler registrations
            if (notificationHandlers.Any())
            {
                sb.AppendLine("            // Notification handler registrations");
                foreach (var handler in notificationHandlers)
                {
                    var lifetime = GetLifetimeString(handler.Lifetime);
                    // Register concrete handler first
                    sb.AppendLine($"            services.Add{lifetime}<{GetTypeName(handler.HandlerType)}>();");
                    // Then register interface mapping
                    sb.AppendLine($"            services.Add{lifetime}<INotificationHandler<{GetTypeName(handler.RequestType)}>>(sp => sp.GetRequiredService<{GetTypeName(handler.HandlerType)}>());");
                }
                sb.AppendLine();
            }

            // Register main dispatcher
            sb.AppendLine("            // Main dispatcher registration (transient to match MediatR behavior)");
            sb.AppendLine("            services.AddTransient<GeneratedRoutya>();");
            sb.AppendLine("            services.AddTransient<IGeneratedRoutya>(sp => sp.GetRequiredService<GeneratedRoutya>());");

            sb.AppendLine("            return services;");
            sb.AppendLine("        }");
            sb.AppendLine("    }");

            sb.AppendLine("}");

            return sb.ToString();
        }

        private static string GetTypeName(Microsoft.CodeAnalysis.INamedTypeSymbol type)
        {
            var ns = type.ContainingNamespace?.IsGlobalNamespace == false
                ? $"{type.ContainingNamespace}."
                : "";
            
            if (type.TypeArguments.Length == 0)
            {
                return $"{ns}{type.Name}";
            }

            // Handle generic types
            var typeArgs = string.Join(", ", type.TypeArguments.Select(GetTypeName));
            return $"{ns}{type.Name}<{typeArgs}>";
        }

        private static string GetTypeName(Microsoft.CodeAnalysis.ITypeSymbol type)
        {
            if (type is Microsoft.CodeAnalysis.INamedTypeSymbol namedType)
            {
                return GetTypeName(namedType);
            }
            return type.Name;
        }

        private static string GetLifetimeString(ServiceLifetime lifetime)
        {
            return lifetime switch
            {
                ServiceLifetime.Singleton => "Singleton",
                ServiceLifetime.Scoped => "Scoped",
                ServiceLifetime.Transient => "Transient",
                _ => "Scoped"
            };
        }
    }
}
