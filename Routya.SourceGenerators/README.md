# Routya v3.0 Source Generator

**Compile-time code generation for zero-overhead request/response dispatching**

The Routya Source Generator analyzes your handlers at compile-time and generates optimized, type-specific dispatch code. This eliminates runtime reflection, reduces allocations, and provides better performance than MediatR while maintaining a clean developer experience.

---

## üéØ Why Source Generation?

**Traditional approach (Runtime):**
- Discovers handlers at startup using reflection
- Uses dictionaries for handler lookup
- Generic constraints resolved at runtime
- Higher memory overhead

**Source Generator approach (Compile-time):**
- ‚úÖ **Zero reflection** - All handlers discovered at compile-time
- ‚úÖ **Zero dictionary lookups** - Direct method calls
- ‚úÖ **Type-specific code** - No generic constraints
- ‚úÖ **Better performance** - 46% faster than MediatR on notifications
- ‚úÖ **Clean IntelliSense** - See all available handlers in IDE
- ‚úÖ **Compile-time safety** - Missing handlers = build errors

---

## üì¶ Installation

```bash
dotnet add package Routya.SourceGenerators --version 3.0.0
```

The source generator automatically references `Routya.Core`, so you don't need to install both.

---

## üöÄ Quick Start

### 1. Define Your Handlers

```csharp
using Routya.Core.Abstractions;

// Request/Response
public class GetUserRequest : IRequest<User>
{
    public int UserId { get; set; }
}

public class GetUserHandler : IAsyncRequestHandler<GetUserRequest, User>
{
    public async Task<User> HandleAsync(GetUserRequest request, CancellationToken cancellationToken)
    {
        return new User { Id = request.UserId, Name = $"User_{request.UserId}" };
    }
}

// Notifications
public class UserCreatedNotification : INotification
{
    public int UserId { get; set; }
}

public class EmailNotificationHandler : INotificationHandler<UserCreatedNotification>
{
    public Task Handle(UserCreatedNotification notification, CancellationToken cancellationToken)
    {
        Console.WriteLine($"Sending email for user {notification.UserId}");
        return Task.CompletedTask;
    }
}
```

### 2. Register with DI

```csharp
using Routya.Generated;

var services = new ServiceCollection();
services.AddGeneratedRoutya();  // ‚ö° Generated by source generator!

var provider = services.BuildServiceProvider();
```

### 3. Dispatch Requests

```csharp
var routya = provider.GetRequiredService<IGeneratedRoutya>();

// Request/Response
var user = await routya.SendAsync(new GetUserRequest { UserId = 123 });

// Notifications (parallel execution)
await routya.PublishAsync(new UserCreatedNotification { UserId = 456 });
```

---

## üî• Features

### ‚úÖ Pipeline Behaviors

Full support for `IPipelineBehavior<TRequest, TResponse>`:

```csharp
public class LoggingBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
{
    public async Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken)
    {
        Console.WriteLine($"Before: {typeof(TRequest).Name}");
        var response = await next(cancellationToken);
        Console.WriteLine($"After: {typeof(TRequest).Name}");
        return response;
    }
}

// Register
services.AddTransient(typeof(IPipelineBehavior<,>), typeof(LoggingBehavior<,>));
services.AddGeneratedRoutya();
```

### ‚úÖ Streaming Support

Use `IAsyncEnumerable<T>` for large datasets:

```csharp
public class GetLargeDatasetRequest : IRequest<IAsyncEnumerable<DataChunk>>
{
    public int TotalRecords { get; set; }
}

public class GetLargeDatasetHandler : IAsyncRequestHandler<GetLargeDatasetRequest, IAsyncEnumerable<DataChunk>>
{
    public async Task<IAsyncEnumerable<DataChunk>> HandleAsync(
        GetLargeDatasetRequest request, 
        CancellationToken cancellationToken)
    {
        return StreamDataAsync(request, cancellationToken);
    }

    private async IAsyncEnumerable<DataChunk> StreamDataAsync(
        GetLargeDatasetRequest request,
        [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        for (int i = 0; i < request.TotalRecords; i += 100)
        {
            yield return new DataChunk { StartIndex = i, Count = 100 };
        }
    }
}

// Usage
var stream = await routya.SendAsync(new GetLargeDatasetRequest { TotalRecords = 1000 });
await foreach (var chunk in stream)
{
    // Process chunk
}
```

### ‚úÖ Generic Type Support

Works seamlessly with generic types:

```csharp
public class GetAllProductsQuery : IRequest<List<Product>> { }

public class CreateProductCommand : IRequest<Product>
{
    public string Name { get; set; }
    public decimal Price { get; set; }
}
```

### ‚úÖ Database Integration

Works with EF Core, Dapper, ADO.NET, etc.:

```csharp
public class GetProductHandler : IAsyncRequestHandler<GetProductQuery, Product>
{
    private readonly ProductDbContext _db;

    public GetProductHandler(ProductDbContext db) => _db = db;

    public async Task<Product> HandleAsync(GetProductQuery request, CancellationToken ct)
    {
        return await _db.Products.FindAsync(request.ProductId, ct);
    }
}
```

---

## üìä Performance

**Benchmark: Request/Response with 2 Pipeline Behaviors**

| Method                     | Mean      | Allocated |
|--------------------------- |----------:|----------:|
| MediatR                    | 337.1 ns  | 1008 B    |
| RoutyaV3_SourceGen         | **335.3 ns**  | 1064 B    |
| RoutyaV2_Runtime           | 365.7 ns  | 0 B       |

**Benchmark: Notifications with 2 Pipeline Behaviors**

| Method                     | Mean      | Allocated |
|--------------------------- |----------:|----------:|
| MediatR                    | 222.5 ns  | 0 B       |
| RoutyaV3_SourceGen         | **120.7 ns**  | 200 B     |
| RoutyaV2_Runtime           | 333.6 ns  | 0 B       |

**Key Takeaways:**
- ‚ö° **46% faster than MediatR** on notifications
- ‚ö° Matches MediatR on request handling
- ‚ö° **64% faster than runtime** Routya on notifications
- üéØ Maintains performance with pipeline behaviors

---

## üîç How It Works

### Generated Code

For this handler:

```csharp
public class GetUserHandler : IAsyncRequestHandler<GetUserRequest, User> { ... }
```

The source generator creates:

**1. Type-Specific Interface:**
```csharp
public interface IGeneratedRoutya
{
    Task<User> SendAsync(GetUserRequest request, CancellationToken cancellationToken = default);
}
```

**2. Optimized Dispatcher:**
```csharp
public sealed class GeneratedRoutya : IGeneratedRoutya
{
    public async Task<User> SendAsync(GetUserRequest request, CancellationToken cancellationToken = default)
    {
        var behaviors = _serviceProvider.GetServices<IPipelineBehavior<GetUserRequest, User>>();
        var handler = _serviceProvider.GetRequiredService<GetUserHandler>();
        
        if (behaviors.Any())
        {
            // Build pipeline
            RequestHandlerDelegate<User> handlerDelegate = (ct) => handler.HandleAsync(request, ct);
            foreach (var behavior in behaviors.Reverse())
            {
                var currentDelegate = handlerDelegate;
                var currentBehavior = behavior;
                handlerDelegate = (ct) => currentBehavior.Handle(request, currentDelegate, ct);
            }
            return await handlerDelegate(cancellationToken);
        }
        
        return await handler.HandleAsync(request, cancellationToken);
    }
}
```

**3. DI Registration:**
```csharp
public static class RoutyaGeneratedExtensions
{
    public static IServiceCollection AddGeneratedRoutya(this IServiceCollection services)
    {
        services.AddTransient<GetUserHandler>();
        services.AddTransient<IAsyncRequestHandler<GetUserRequest, User>>(sp => 
            sp.GetRequiredService<GetUserHandler>());
        
        services.AddTransient<GeneratedRoutya>();
        services.AddTransient<IGeneratedRoutya>(sp => 
            sp.GetRequiredService<GeneratedRoutya>());
        
        return services;
    }
}
```

---

## üéì Examples

Check out the example projects:

- **[Routya.SourceGen.Demo](../Routya.SourceGen.Demo)** - Basic usage with requests, notifications, pipelines, and streaming
- **[Routya.SourceGen.DatabaseDemo](../Routya.SourceGen.DatabaseDemo)** - SQLite integration with CRUD operations
- **[Routya.SourceGen.Benchmark](../Routya.SourceGen.Benchmark)** - Performance comparisons with MediatR

---

## üîÑ Migration from Routya v2.0 (Runtime)

### Before (Runtime):
```csharp
services.AddRoutya(cfg => 
{
    cfg.Scope = RoutyaDispatchScope.Scoped;
    cfg.HandlerLifetime = ServiceLifetime.Scoped;
}, Assembly.GetExecutingAssembly());

var routya = provider.GetRequiredService<IRoutya>();
var user = await routya.SendAsync<GetUserRequest, User>(request);
```

### After (Source Generator):
```csharp
services.AddGeneratedRoutya();

var routya = provider.GetRequiredService<IGeneratedRoutya>();
var user = await routya.SendAsync(request);  // No type arguments!
```

**Key Differences:**
1. **No assembly scanning** - Handlers discovered at compile-time
2. **IGeneratedRoutya** instead of `IRoutya` - Type-specific interface
3. **No type arguments** - Clean API with IntelliSense
4. **Better performance** - Zero reflection, zero dictionary lookups

---

## ‚ö†Ô∏è Limitations

1. **Single Assembly** - The source generator discovers handlers in the same assembly only
2. **Partial Classes Not Supported** - Handlers must be complete in a single file
3. **Generic Handlers** - Handler types themselves cannot be generic (but request/response types can be)

---

## ü§ù Contributing

See [CONTRIBUTING.md](../CONTRIBUTING.md) for guidelines.

---

## üìÑ License

MIT License - see [LICENSE](../LICENSE) for details.

---

## üîó Links

- **NuGet**: [Routya.SourceGenerators](https://www.nuget.org/packages/Routya.SourceGenerators)
- **GitHub**: [hbartosch/routya](https://github.com/hbartosch/routya)
- **Issues**: [Report bugs](https://github.com/hbartosch/routya/issues)
