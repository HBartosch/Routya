# Getting Started with Routya v3 Source Generator

This guide will help you get up and running with Routya's compile-time source generator in just a few minutes.

---

## üìã Prerequisites

- **.NET SDK 8.0+** (or .NET 9/10)
- **Visual Studio 2022** or **VS Code** with C# extension
- **C# 11+** language version

---

## üöÄ Installation

### Option 1: Using .NET CLI

```bash
dotnet add package Routya.SourceGenerators --version 3.0.0
```

### Option 2: Using Package Manager Console

```powershell
Install-Package Routya.SourceGenerators -Version 3.0.0
```

### Option 3: Manually Edit .csproj

```xml
<ItemGroup>
  <PackageReference Include="Routya.SourceGenerators" Version="3.0.0" />
</ItemGroup>
```

The `Routya.SourceGenerators` package automatically includes `Routya.Core`, so you don't need both.

---

## üìù Step 1: Define Your First Request Handler

Create a request and handler:

```csharp
using Routya.Core.Abstractions;

namespace MyApp.Features.Users;

// The request
public class GetUserRequest : IRequest<User>
{
    public int UserId { get; set; }
}

// The response
public class User
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
}

// The handler
public class GetUserHandler : IAsyncRequestHandler<GetUserRequest, User>
{
    public async Task<User> HandleAsync(
        GetUserRequest request, 
        CancellationToken cancellationToken)
    {
        // Your logic here (database query, API call, etc.)
        await Task.Delay(10, cancellationToken); // Simulate work
        
        return new User 
        { 
            Id = request.UserId, 
            Name = $"User_{request.UserId}" 
        };
    }
}
```

---

## üîß Step 2: Register with Dependency Injection

In your `Program.cs` or `Startup.cs`:

```csharp
using Microsoft.Extensions.DependencyInjection;
using Routya.Generated; // Generated namespace

var builder = WebApplication.CreateBuilder(args);

// Register the source-generated dispatcher
builder.Services.AddGeneratedRoutya();

var app = builder.Build();
```

**Note:** `AddGeneratedRoutya()` is a method generated by the source generator. It automatically registers:
- All discovered handlers
- The `IGeneratedRoutya` interface
- The `GeneratedRoutya` implementation

---

## üíâ Step 3: Inject and Use

### In a Controller (ASP.NET Core)

```csharp
using Microsoft.AspNetCore.Mvc;
using Routya.Generated;

[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    private readonly IGeneratedRoutya _routya;

    public UsersController(IGeneratedRoutya routya)
    {
        _routya = routya;
    }

    [HttpGet("{userId}")]
    public async Task<IActionResult> GetUser(int userId)
    {
        var request = new GetUserRequest { UserId = userId };
        var user = await _routya.SendAsync(request);
        return Ok(user);
    }
}
```

### In a Console Application

```csharp
using Microsoft.Extensions.DependencyInjection;
using Routya.Generated;

var services = new ServiceCollection();
services.AddGeneratedRoutya();

var provider = services.BuildServiceProvider();
var routya = provider.GetRequiredService<IGeneratedRoutya>();

// Use it
var user = await routya.SendAsync(new GetUserRequest { UserId = 123 });
Console.WriteLine($"User: {user.Name}");
```

---

## üîî Step 4: Add Notifications (Optional)

Notifications are fire-and-forget messages handled by multiple handlers in parallel:

```csharp
using Routya.Core.Abstractions;

// Define the notification
public class UserCreatedNotification : INotification
{
    public int UserId { get; set; }
    public string Email { get; set; } = string.Empty;
}

// First handler - Send welcome email
public class SendWelcomeEmailHandler : INotificationHandler<UserCreatedNotification>
{
    public async Task Handle(
        UserCreatedNotification notification, 
        CancellationToken cancellationToken)
    {
        Console.WriteLine($"Sending welcome email to {notification.Email}");
        await Task.Delay(10, cancellationToken);
    }
}

// Second handler - Log to analytics
public class LogAnalyticsHandler : INotificationHandler<UserCreatedNotification>
{
    public async Task Handle(
        UserCreatedNotification notification, 
        CancellationToken cancellationToken)
    {
        Console.WriteLine($"Logging user creation: {notification.UserId}");
        await Task.Delay(5, cancellationToken);
    }
}

// Publish notification
await routya.PublishAsync(new UserCreatedNotification 
{ 
    UserId = 456, 
    Email = "user@example.com" 
});
```

**Both handlers execute in parallel automatically!**

---

## üéØ Step 5: Add Pipeline Behaviors (Optional)

Pipeline behaviors wrap your handlers for cross-cutting concerns:

```csharp
using Routya.Core.Abstractions;

public class LoggingBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
{
    private readonly ILogger<LoggingBehavior<TRequest, TResponse>> _logger;

    public LoggingBehavior(ILogger<LoggingBehavior<TRequest, TResponse>> logger)
    {
        _logger = logger;
    }

    public async Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken)
    {
        var requestName = typeof(TRequest).Name;
        
        _logger.LogInformation("Handling {RequestName}", requestName);
        
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        var response = await next(cancellationToken);
        stopwatch.Stop();
        
        _logger.LogInformation("Handled {RequestName} in {ElapsedMs}ms", 
            requestName, stopwatch.ElapsedMilliseconds);
        
        return response;
    }
}

// Register
services.AddTransient(typeof(IPipelineBehavior<,>), typeof(LoggingBehavior<,>));
services.AddGeneratedRoutya();
```

Behaviors execute in registration order, wrapping your handler like an onion.

---

## üèóÔ∏è Build and See Generated Code

Build your project:

```bash
dotnet build
```

The source generator creates files in `obj/Generated/Routya.SourceGenerators/`:
- `RoutyaGenerated.Dispatcher.g.cs` - Type-specific dispatcher
- `RoutyaGenerated.Registration.g.cs` - DI registration + interface

You can view these files in Visual Studio:
1. Expand **Dependencies** ‚Üí **Analyzers** ‚Üí **Routya.SourceGenerators**
2. See the generated `.g.cs` files

---

## ‚úÖ Verify Everything Works

Run your application and test:

```csharp
var user = await routya.SendAsync(new GetUserRequest { UserId = 123 });
Console.WriteLine($"‚úÖ Got user: {user.Name}");

await routya.PublishAsync(new UserCreatedNotification 
{ 
    UserId = 456, 
    Email = "test@example.com" 
});
Console.WriteLine("‚úÖ Notification published");
```

Expected output:
```
Handling GetUserRequest
Handled GetUserRequest in 12ms
‚úÖ Got user: User_123
Sending welcome email to test@example.com
Logging user creation: 456
‚úÖ Notification published
```

---

## üéì Next Steps

Now that you have the basics working:

1. **Add Database Integration** - See [Database Demo](../Routya.SourceGen.DatabaseDemo)
2. **Explore Streaming** - Use `IAsyncEnumerable<T>` for large datasets
3. **Add More Behaviors** - Validation, caching, error handling, etc.
4. **Check Performance** - Run benchmarks to see the speed gains

---

## üÜò Troubleshooting

### "AddGeneratedRoutya() doesn't exist"

**Solution:** Build your project first. The source generator needs to run:
```bash
dotnet build
```

### "No handlers discovered"

**Checklist:**
- ‚úÖ Handlers implement `IAsyncRequestHandler<TRequest, TResponse>` or `INotificationHandler<TNotification>`
- ‚úÖ Handlers are in the **same assembly** where you call `AddGeneratedRoutya()`
- ‚úÖ Handler classes are `public` (not `internal`)
- ‚úÖ Project has been built successfully

### "IGeneratedRoutya not found"

**Solution:** Add the using directive:
```csharp
using Routya.Generated;
```

### IDE IntelliSense not showing generated code

**Solution:** 
1. Rebuild the project
2. Close and reopen the file
3. Restart Visual Studio/VS Code

---

## üìö Additional Resources

- [README.md](./README.md) - Full feature documentation
- [Release Notes](../RELEASE_NOTES_V3.md) - What's new in v3.0
- [Examples](../Routya.SourceGen.Demo) - Complete working examples
- [GitHub Issues](https://github.com/hbartosch/routya/issues) - Report bugs

---

## üí° Tips

1. **Use `IGeneratedRoutya` in production code** - Better IntelliSense and type safety
2. **Register behaviors before `AddGeneratedRoutya()`** - Ensures proper ordering
3. **Keep handlers in the same assembly** - Source generator limitation
4. **Use dependency injection** - Handlers can inject any service
5. **Cancellation tokens** - Always pass `CancellationToken` to async operations

Happy dispatching! üöÄ
